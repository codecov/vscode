{
  "beta_groups": {
    "desc": "To see Impacted Entry points in your pull request comments, 'betaprofiling' must be added to the comment.layout section of your codecov.yml."
  },
  "codecov": {
    "desc": "Configure general CodeCov settings. [More information](https://.codecov.com//codecov-yaml)."
  },
  "codecov.allow_coverage_offsets": {
    "desc": "Codecov will calculate a coverage diff based on the last coverage found and the diff to the base commit. [More information](https://.codecov.com//comparing-commits#comparing-pull-request-base-reports). Options include: 'True', 'False', 'yes', 'no', 'on', 'off'."
  },
  "codecov.allow_pseudo_compare": {
    "desc": "Allow Codecov to find an alternative base if the base of comparison has no coverage. [More information](https://.codecov.com//comparing-commits#comparing-pull-request-base-reports). Options include: 'True', 'False', 'yes', 'no', 'on', 'off'."
  },
  "codecov.archive": {
    "desc": "Configure cloud report archiving."
  },
  "codecov.archive.uploads": {
    "desc": "Disable Codecov cloud report archiving? [More information](https://.codecov.com/v4.6//codecovyml-reference#codecov-cloud-report-archiving). Options include: 'True', 'False', 'yes', 'no', 'on', 'off'."
  },
  "codecov.assume_all_flags": {
    "desc": "Deprecated"
  },
  "codecov.bot": {
    "desc": "The username you want to use for Codecov operations. [More information](https://docs.codecov.com/docs/team-bot)."
  },
  "codecov.branch": {
    "desc": "Specify a branch manually in your YAML"
  },
  "codecov.ci": {
    "desc": "Additional CI provider URLs you want Codecov to recognize. [More information](https://docs.codecov.com/docs/detecting-ci-services)."
  },
  "codecov.disable_default_path_fixes": {
    "desc": "Should Codecov's default path fixes be disabled? [More information](https://docs.codecov.io/docs/fixing-paths). Options include: 'True', 'False', 'yes', 'no', 'on', 'off'."
  },
  "codecov.max_report_age": {
    "desc": "The age you want coverage reports to expire at, or if you want to disable this check. Expired reports will not be processed by CodeCov. [More information](https://docs.codecov.io/docs/codecov-yaml#section-expired-reports)."
  },
  "codecov.notify": {
    "desc": "Configure how Codecov sends a PR comment"
  },
  "codecov.notify.after_n_builds": {
    "desc": "How many uploaded reports Codecov should wait to receive before sending statuses? [More information](https://.codecov.io//notifications#section-preventing-notifications-until-after-n-builds)."
  },
  "codecov.notify.countdown": {
    "desc": "Deprecated"
  },
  "codecov.notify.delay": {
    "desc": "Deprecated"
  },
  "codecov.notify.require_ci_to_pass": {
    "desc": "Wait for all CI statuses to pass? [More information](https://.codecov.com//codecovyml-reference#codecovrequire_ci_to_pass). Options include: 'True', 'False', 'yes', 'no', 'on', 'off'."
  },
  "codecov.notify.wait_for_ci": {
    "desc": "Wait for CI to finish sending notifications? [More information](https://.codecov.com//codecovyml-reference#codecovnotifywait_for_ci). Options include: 'True', 'False', 'yes', 'no', 'on', 'off'."
  },
  "codecov.require_ci_to_pass": {
    "desc": "Should Codecov wait for all other statuses to pass before sending its status? Options include: 'True', 'False', 'yes', 'no', 'on', 'off'"
  },
  "codecov.slug": {
    "desc": "Self Hosted only - specify a slug manually"
  },
  "codecov.strict_yaml_branch": {
    "desc": "Specify a branch you want Codecov to always only read the YAML from. [More information](https://docs.codecov.io/docs/codecov-yaml#section-restricting-changes)."
  },
  "codecov.token": {
    "desc": "The repository upload token. [More information](https://docs.codecov.com/docs/codecov-uploader#upload-token)."
  },
  "codecov.ui": {
    "desc": "Deprecated"
  },
  "codecov.ui.hide_complexity": {
    "desc": "Deprecated"
  },
  "codecov.ui.hide_contexual": {
    "desc": "Deprecated"
  },
  "codecov.ui.hide_density": {
    "desc": "Deprecated"
  },
  "codecov.ui.hide_search": {
    "desc": "Deprecated"
  },
  "codecov.ui.hide_sunburst": {
    "desc": "Deprecated"
  },
  "codecov.url": {
    "desc": "A URL you want to send notifications to. [More information](https://docs.codecov.com/docs/notifications#standard-notification-fields)."
  },
  "comment": {
    "desc": "Refer to the feedback or remarks that Codecov can provide on your code coverage results. These comments are typically added to pull requests or specific lines of code to provide additional information or suggestions regarding the code coverage analysis."
  },
  "comment.after_n_builds": {
    "desc": "If you want to add comments that appear after a specific number of builds or iterations for coverage analysis, you can include the phrase 'After n builds' or any other relevant keyword, you communicate that these comments should be taken into account after a specific number of builds or iterations."
  },
  "comment.behavior": {
    "desc": "When adding comments to describe the behavior of your code for coverage analysis, use the phrase 'Behavior' or any other relevant keyword, you make it clear that these comments describe the expected behavior of the code."
  },
  "comment.branches": {
    "desc": "Comment branches refer to the specific branches or conditions under which comments are generated during the code coverage analysis. These comments provide feedback, suggestions, or information related to code coverage for specific branches of your codebase."
  },
  "comment.branches.items": {
    "desc": "If you want to add comments to specify branches or items within your code for coverage analysis, you can include terms like 'Branch' or any other relevant keyword, you clearly communicate the specific branches or items within the code that are relevant for coverage analysis."
  },
  "comment.flags": {
    "desc": "Comment flags refer to special markers or indicators that can be added to comments in your code to control the behavior of Codecov's code coverage analysis."
  },
  "comment.flags.items": {
    "desc": "If you want to add comments to specify flags or items within your code for coverage analysis, you can use terms like 'Flag' or any other relevant keyword, you clearly communicate the specific flags or items within the code that are relevant for coverage analysis. "
  },
  "comment.hide_comment_details": {
    "desc": "If you want to add comments but hide the specific details or implementation information within the comments for coverage analysis, you can use abstract or generic descriptions to hide the specific details of the code implementation within the comments while still conveying the coverage significance of different sections."
  },
  "comment.layout": {
    "desc": "Comment layout refers to the structure and formatting of the comments generated during the code coverage analysis process. The layout of comments can vary depending on the specific features and configurations of, as well as the platform or integration being used."
  },
  "comment.layout.comma_separated_strings": {
    "desc": "Split the comma-separated data into a list of values to  provide clarity to developers and reviewers about the specific parts of the code that are relevant to code coverage analysis when dealing with comma-separated strings."
  },
  "comment.paths": {
    "desc": "Comment paths refer to the specific locations within your codebase where comments are added to provide feedback or information related to code coverage analysis. Comment paths can be associated with individual lines of code, code sections, or specific files."
  },
  "comment.require_base": {
    "desc": "To indicate that a certain code section requires a base or starting point for coverage analysis add the phrase 'Base required' or any other relevant keyword, you clearly communicate that a starting point or base coverage is necessary to accurately assess the coverage of those specific code sections."
  },
  "comment.require_changes": {
    "desc": "If you need to indicate in your comments that certain code requires changes or modifications, you can use specific keywords or phrases to convey this information. You can tailor the comments to suit your specific needs by using keywords like 'TODO,' 'FIXME,' or 'CHANGES NEEDED' to explicitly communicate that certain code sections need attention."
  },
  "comment.require_head": {
    "desc": "If you want to add comments to indicate that a certain code section requires a 'head' or an updated state for coverage analysis, you can add the phrase 'Head required' or any other relevant keyword, you clearly communicate that an updated or current state of the code is needed to accurately assess the coverage of those specific code sections."
  },
  "comment.show_carryforward_flags": {
    "desc": "If you want to add comments to indicate the presence of carry-forward flags in your code for coverage analysis, you can use the phrase 'Carry-forward Flag' or any other relevant keyword, you clearly communicate the presence of carry-forward flags and their significance for coverage analysis. "
  },
  "comment.show_critical_paths": {
    "desc": "When adding comments to highlight the critical path of your code, you can include the phrase 'Critical Path' or any other relevant keyword, you explicitly communicate the essential steps in the code execution flow."
  },
  "component_management": {
    "desc": "Use components you specify to create custom statuses and get coverage information from parts of your code that are not easily broken up into different uploads or span multiple flag groups."
  },
  "component_management.default_rules": {
    "desc": "Rules are a set of defined conditions and actions that control the behavior of components during the code coverage analysis process."
  },
  "component_management.default_rules.flag_regexes": {
    "desc": "Refers to the use of regular expressions to define patterns for matching specific flags or conditions during the code coverage analysis process."
  },
  "component_management.default_rules.paths": {
    "desc": "Define rules that specify conditions and actions for component management. These rules can be based on various criteria such as coverage thresholds, branch names, commit messages, or other factors relevant to your project."
  },
  "component_management.default_rules.statuses": {
    "desc": "Component management rule statuses refer to the different states or conditions associated with component management rules."
  },
  "component_management.individual_components": {
    "desc": "Individual components refer to specific configuration options or settings that can be used to customize the behavior of the code coverage reporting and analysis process."
  },
  "coverage": {
    "desc": "Configuration options that determine how Codecov calculates and reports on code coverage metrics."
  },
  "coverage.notify": {
    "desc": "A collection of notification tools for sending coverage data to services outside of Git. Out-of-the-box tools are Slack and Gitter, or you can make your own webhook. Available keys are slack, gitter, webhook, and after_n_builds. [Read about Codecov notifications here](https://.codecov.com//notifications)."
  },
  "coverage.notify.email": {
    "desc": "Deprecated"
  },
  "coverage.notify.email.[any].base": {
    "desc": "Deprecated"
  },
  "coverage.notify.email.[any].branches": {
    "desc": "Deprecated"
  },
  "coverage.notify.email.[any].flags": {
    "desc": "Deprecated"
  },
  "coverage.notify.email.[any].layout": {
    "desc": "Deprecated"
  },
  "coverage.notify.email.[any].message": {
    "desc": "Deprecated"
  },
  "coverage.notify.email.[any].only_pulls": {
    "desc": "Deprecated"
  },
  "coverage.notify.email.[any].paths": {
    "desc": "Deprecated"
  },
  "coverage.notify.email.[any].threshold": {
    "desc": "Deprecated"
  },
  "coverage.notify.email.[any].to": {
    "desc": "Deprecated"
  },
  "coverage.notify.email.[any].url": {
    "desc": "Deprecated"
  },
  "coverage.notify.gitter": {
    "desc": "This is the root for Gitter notifications to fire. Below \"gitter:\" start your configuration with an indented \"default:\". Available keys after \"default:\" are URL, Threshold, Only_pulls, Branches, Flags, and Paths. [Gitter notification ](https://.codecov.com//notifications#gitter)"
  },
  "coverage.notify.gitter.[any].base": {
    "desc": "The base commit type to which you would like to send notifications. Options include: 'parent', 'pr', and 'auto'. parent: compare the commit being notified on, to its direct parent. 'pr': compare the commit being notified on, to the base of a PR if the commit is in a PR. 'auto': automatically choose the appropriate comparison. If the commit being notified on is in a PR, pr will be used, otherwise parent will be used. This is the default."
  },
  "coverage.notify.gitter.[any].branches": {
    "desc": "Used to store the branch(es) that will report code coverage. Defaults to all branches. Each new branch is a new indented line"
  },
  "coverage.notify.gitter.[any].flags": {
    "desc": "Specify the flags for which you would like notifications to be sent. Defaults to all flags. [Read more about flags](https://.codecov.com//flags). Add a new, indented line for each flag. Regular expressions are permitted with the pattern: ^[\\w\\.\\-]{1,45}$"
  },
  "coverage.notify.gitter.[any].message": {
    "desc": "A customizable message to send in the notification"
  },
  "coverage.notify.gitter.[any].only_pulls": {
    "desc": "True / False binary to specify if you only want notifications to fire on pull requests (vs. individual commits on the branch). Default is `false`, which will notify on all new commits."
  },
  "coverage.notify.gitter.[any].paths": {
    "desc": "Only send a notification if the specified file paths change. Augments the flags setting. Add a new, indented line for each path. If both flags and paths are specified, a notification will be triggered if files covered by the supplied flags OR paths change."
  },
  "coverage.notify.gitter.[any].threshold": {
    "desc": "The coverage threshold on which you would like to send a notification. If the coverage changes by more than the amount in the threshold field, a notification will be sent, otherwise, it will not. Default to `None`, which means that notifications will always be sent regardless of coverage change amount."
  },
  "coverage.notify.gitter.[any].url": {
    "desc": "Used to store the Gitter hooks URL associated with your Gitter notifier: \"https://webhooks.gitter.im/e/9d1957r0a481787c756z\""
  },
  "coverage.notify.hipchat.[any].base": {
    "desc": "Deprecated"
  },
  "coverage.notify.hipchat.[any].branches": {
    "desc": "Deprecated"
  },
  "coverage.notify.hipchat.[any].card": {
    "desc": "Deprecated"
  },
  "coverage.notify.hipchat.[any].flags": {
    "desc": "Deprecated"
  },
  "coverage.notify.hipchat.[any].message": {
    "desc": "Deprecated"
  },
  "coverage.notify.hipchat.[any].notify": {
    "desc": "Deprecated"
  },
  "coverage.notify.hipchat.[any].only_pulls": {
    "desc": "Deprecated"
  },
  "coverage.notify.hipchat.[any].paths": {
    "desc": "Deprecated"
  },
  "coverage.notify.hipchat.[any].threshold": {
    "desc": "Deprecated"
  },
  "coverage.notify.hipchat.[any].url": {
    "desc": "Deprecated"
  },
  "coverage.notify.irc": {
    "desc": "Deprecated"
  },
  "coverage.notify.irc.[any].base": {
    "desc": "Deprecated"
  },
  "coverage.notify.irc.[any].branches": {
    "desc": "Deprecated"
  },
  "coverage.notify.irc.[any].channel": {
    "desc": "Deprecated"
  },
  "coverage.notify.irc.[any].flags": {
    "desc": "Deprecated"
  },
  "coverage.notify.irc.[any].message": {
    "desc": "Deprecated"
  },
  "coverage.notify.irc.[any].nickserv_password": {
    "desc": "Deprecated"
  },
  "coverage.notify.irc.[any].notice": {
    "desc": "Deprecated"
  },
  "coverage.notify.irc.[any].only_pulls": {
    "desc": "Deprecated"
  },
  "coverage.notify.irc.[any].password": {
    "desc": "Deprecated"
  },
  "coverage.notify.irc.[any].paths": {
    "desc": "Deprecated"
  },
  "coverage.notify.irc.[any].server": {
    "desc": "Deprecated"
  },
  "coverage.notify.irc.[any].threshold": {
    "desc": "Deprecated"
  },
  "coverage.notify.irc.[any].url": {
    "desc": "Deprecated"
  },
  "coverage.notify.slack": {
    "desc": "This is the path for Slack notifications to fire. Below \"slack:\" start your configuration with an indented \"default:\". Available keys after \"default:\" are URL, Threshold, Only_pulls, Branches, Flags, and Paths. [Slack notification](https://.codecov.com//notifications#slack)"
  },
  "coverage.notify.slack.[any].attachments": {
    "desc": "These are attachments you can make as strings to the Slack notifier with the pattern: ^([^,]+)(,[^,]+)*$"
  },
  "coverage.notify.slack.[any].base": {
    "desc": "The base commit type to which you would like to send notifications. Options include: 'parent', 'pr', and 'auto'. parent: compare the commit being notified on, to its direct parent. 'pr': compare the commit being notified on, to the base of a PR if the commit is in a PR. 'auto': automatically choose the appropriate comparison. If the commit being notified on is in a PR, pr will be used, otherwise parent will be used. This is the default."
  },
  "coverage.notify.slack.[any].branches": {
    "desc": "Used to store the branch(es) that will report code coverage. Defaults to all branches. Each new branch is a new indented line"
  },
  "coverage.notify.slack.[any].flags": {
    "desc": "Specify the flags for which you would like notifications to be sent. Defaults to all flags. [Read more about flags](https://.codecov.com//flags). Add a new, indented line for each flag. Regular expressions are permitted with the pattern: ^[\\w\\.\\-]{1,45}$"
  },
  "coverage.notify.slack.[any].message": {
    "desc": "A customizable message to send in the notification"
  },
  "coverage.notify.slack.[any].only_pulls": {
    "desc": "True / False binary to specify if you only want notifications to fire on pull requests (vs. individual commits on the branch). Default is `false`, which will notify on all new commits."
  },
  "coverage.notify.slack.[any].paths": {
    "desc": "Only send a notification if the specified file paths change. Augments the flags setting. Add a new, indented line for each path. If both flags and paths are specified, a notification will be triggered if files covered by the supplied flags OR paths change."
  },
  "coverage.notify.slack.[any].threshold": {
    "desc": "The coverage threshold on which you would like to send a notification. If the coverage changes by more than the amount in the threshold field, a notification will be sent, otherwise, it will not. Default to `None`, which means that notifications will always be sent regardless of coverage change amount."
  },
  "coverage.notify.slack.[any].url": {
    "desc": "Used to store the Slack hooks URL associated with your Slack notifier: https://hooks.slack.com/services/abc/123"
  },
  "coverage.notify.webhook": {
    "desc": "This is the root for making a webhook for notifications outside of Slack or Gitter. Below \"webhook:\" start your configuration with an indented \"default:\". Available keys after \"default:\" are URL, Threshold, Only_pulls, Branches, Flags, and Paths. [General notification ](https://.codecov.com//notifications#standard-notification-fields)"
  },
  "coverage.notify.webhook.[any].base": {
    "desc": "The base commit type to which you would like to send notifications. Options include: 'parent', 'pr', and 'auto'. parent: compare the commit being notified on, to its direct parent. 'pr': compare the commit being notified on, to the base of a PR if the commit is in a PR. 'auto': automatically choose the appropriate comparison. If the commit being notified on is in a PR, pr will be used, otherwise parent will be used. This is the default."
  },
  "coverage.notify.webhook.[any].branches": {
    "desc": "Used to store the branch(es) that will report code coverage. Defaults to all branches. Each new branch is a new indented line"
  },
  "coverage.notify.webhook.[any].flags": {
    "desc": "Specify the flags for which you would like notifications to be sent. Defaults to all flags. [Read more about flags](https://.codecov.com//flags). Add a new, indented line for each flag. Regular expressions are permitted with the pattern: ^[\\w\\.\\-]{1,45}$"
  },
  "coverage.notify.webhook.[any].message": {
    "desc": "A customizable message to send in the notification"
  },
  "coverage.notify.webhook.[any].only_pulls": {
    "desc": "True / False binary to specify if you only want notifications to fire on pull requests (vs. individual commits on the branch). Default is `false`, which will notify on all new commits."
  },
  "coverage.notify.webhook.[any].paths": {
    "desc": "Only send a notification if the specified file paths change. Augments the flags setting. Add a new, indented line for each path. If both flags and paths are specified, a notification will be triggered if files covered by the supplied flags OR paths change."
  },
  "coverage.notify.webhook.[any].threshold": {
    "desc": "The coverage threshold on which you would like to send a notification. If the coverage changes by more than the amount in the threshold field, a notification will be sent, otherwise, it will not. Default to `None`, which means that notifications will always be sent regardless of coverage change amount."
  },
  "coverage.notify.webhook.[any].url": {
    "desc": "Used to store the generalized webhook URL associated with your notifier"
  },
  "coverage.precision": {
    "desc": "What precision do you want the coverage value to be? [More information](https://.codecov.com//codecovyml-reference#coverageprecision)."
  },
  "coverage.range": {
    "desc": "Configure how you want Codecov to color your coverage. Coverage below the first number will be red, coverage between each number yellow, and coverage above the second number will be green. Format: xx...yy "
  },
  "coverage.round": {
    "desc": "Configure how you want Codecov to round your coverage numbers. Options include: 'down', 'up', 'nearest'."
  },
  "coverage.status": {
    "desc": "Configuration for various status checks supported in Codecov. Useful for blocking Pull Requests that don't meet a particular coverage threshold. [More information](https://.codecov.com//commit-status)"
  },
  "coverage.status.changes": {
    "desc": "Codecov will detect changes in coverage that are NOT included in the commit/pull diff, and report these changes as a commit status. [More information](https://.codecov.com//commit-status#changes-status)"
  },
  "coverage.status.changes.[any].base": {
    "desc": "[Deprecated] Base picking approach to use for changes statues. Options include: 'parent', 'pr', 'auto'. It is recommended to use [Codecov CLI's base picking feature](https://.codecov.com//cli-options#pr-base-picking) instead."
  },
  "coverage.status.changes.[any].branches": {
    "desc": "The branches for which the changes status will be active. Nullable."
  },
  "coverage.status.changes.[any].carryforward_behavior": {
    "desc": "Determines how we handle status checks for which flags that were carried forward. This is useful if, for example, you're working on a project in a monorepo and don't want to see status checks related to other projects. Note that this only applies to status checks that specify flags. If there are no flags on a check, the status check will be processed as usual.  Options include: a.) 'include': (default) All the status checks defined in the YAML file will be processed and sent as normal b.) 'exclude': Status checks that carried forward coverage will not be included c.) 'pass': Status checks that have carried forward coverage will pass automatically."
  },
  "coverage.status.changes.[any].disable_approx": {
    "desc": "Deprecated"
  },
  "coverage.status.changes.[any].enabled": {
    "desc": "Deprecated"
  },
  "coverage.status.changes.[any].flag_coverage_not_uploaded_behavior": {
    "desc": "Determines how we handle status checks for which no flag coverage has been newly uploaded on a commit. Options include: 'include', 'exclude', 'pass'. [More information](https://.codecov.com//commit-status#flag_coverage_not_uploaded_behavior)"
  },
  "coverage.status.changes.[any].flags": {
    "desc": "A list of user-defined Flags to use for the changes check. The combined coverage from those flags will be reported. Flag names must match pattern: ^[\\w\\.\\-]{1,45}$"
  },
  "coverage.status.changes.[any].if_ci_failed": {
    "desc": "The status to send if CI fails. Options include: 'success', 'failure'. On error Codecov will on set a passing status if CI passes, on success Codecov will set the status to success even if CI fails."
  },
  "coverage.status.changes.[any].if_no_uploads": {
    "desc": "Deprecated"
  },
  "coverage.status.changes.[any].if_not_found": {
    "desc": "The status to send if there is no report for the head. Options include: 'failure', 'success'. 'failure': the status will fail if there is no report for the head. 'success': the status will pass if there is no report for the head. Use this on commits / PRs where you won't be uploading coverage but still want codecov status checks to pass."
  },
  "coverage.status.changes.[any].informational": {
    "desc": "Use Codecov in informational mode. Default is `false`. If `true` is specified the resulting status will pass no matter what the coverage is or what other settings are specified."
  },
  "coverage.status.changes.[any].measurement": {
    "desc": "Specify the type of coverage measurement. Options include: `line`, `statement`, `branch`, `method`, `complexity`"
  },
  "coverage.status.changes.[any].only_pulls": {
    "desc": "True / False binary to specify if you only want notifications to fire on pull requests (vs. individual commits on the branch). Default is `false`, which will notify on all new commits."
  },
  "coverage.status.changes.[any].paths": {
    "desc": "Paths to consider when determining the status result. [More information](https://.codecov.com//commit-status#paths)"
  },
  "coverage.status.changes.[any].removed_code_behavior": {
    "desc": "These behaviors allow users to specify what should happen to the project status in case changes causes overall coverage to drop, but are part of good development practices. Options include: 'removals_only', 'adjust_base', 'fully_covered_patch', 'off', 'False'. [More information](https://.codecov.com//commit-status#removed_code_behavior)"
  },
  "coverage.status.changes.[any].skip_if_assumes": {
    "desc": "Deprecated"
  },
  "coverage.status.changes.flags": {
    "desc": "A list of user-defined Flags to use for the changes check. The combined coverage from those flags will be reported. Flag names must match pattern: ^[\\w\\.\\-]{1,45}$"
  },
  "coverage.status.default_rules": {
    "desc": "A path of the `status` configuration that provides advanced configuration for repos not uploading all of their coverage on every commit. Keys available are `flag_coverage_not_uploaded_behavior` and `carryforward_behavior`."
  },
  "coverage.status.default_rules.carryforward_behavior": {
    "desc": "Determines how we handle status checks for which flags that were carried forward. This is useful if, for example, you're working on a project in a monorepo and don't want to see status checks related to other projects. Note that this only applies to status checks that specify flags. If there are no flags on a check, the status check will be processed as usual.  Options include: a.) 'include': (default) All the status checks defined in the YAML file will be processed and sent as normal b.) 'exclude': Status checks that carried forward coverage will not be included c.) 'pass': Status checks that have carried forward coverage will pass automatically."
  },
  "coverage.status.default_rules.flag_coverage_not_uploaded_behavior": {
    "desc": "Determines how we handle status checks for which no flag coverage has been newly uploaded on a commit. This includes status checks where flags have carried forward coverage (since coverage was not newly uploaded), as well as flags for which coverage is missing entirely. This is useful if, for example, you're working on a project in a monorepo and don't want to see status checks related to other projects. Note that this only applies to status checks that specify flags. If there are no flags on a check, the status check will be processed as usual.  Options include: a.) 'include': (default) All the status checks defined in the YAML file will be processed and sent as normal b.) 'exclude': Status checks that haven't newly uploaded any flag coverage will not be sent c.) 'pass': Status checks that haven't newly uploaded any flag coverage will be passed automatically."
  },
  "coverage.status.patch": {
    "desc": "Contains the configuration for a given patch status check. Setting to False will disable the patch status check."
  },
  "coverage.status.patch.[any].base": {
    "desc": "The base commit type to which you would like to send notifications. Options include: 'parent', 'pr', and 'auto'. parent: compare the commit being notified on, to its direct parent. 'pr': compare the commit being notified on, to the base of a PR if the commit is in a PR. 'auto': automatically choose the appropriate comparison. If the commit being notified on is in a PR, pr will be used, otherwise parent will be used. This is the default."
  },
  "coverage.status.patch.[any].branches": {
    "desc": "A list of the branches that, when used, will trigger this status."
  },
  "coverage.status.patch.[any].carryforward_behavior": {
    "desc": "Determines how we handle status checks for which flags that were carried forward. This is useful if, for example, you're working on a project in a monorepo and don't want to see status checks related to other projects. Note that this only applies to status checks that specify flags. If there are no flags on a check, the status check will be processed as usual.  Options include: a.) 'include': (default) All the status checks defined in the YAML file will be processed and sent as normal b.) 'exclude': Status checks that carried forward coverage will not be included c.) 'pass': Status checks that have carried forward coverage will pass automatically."
  },
  "coverage.status.patch.[any].disable_approx": {
    "desc": "Deprecated"
  },
  "coverage.status.patch.[any].enabled": {
    "desc": "Deprecated"
  },
  "coverage.status.patch.[any].flag_coverage_not_uploaded_behavior": {
    "desc": "Determines how to handle status checks for which no flag coverage (including carryforward flags) has been newly uploaded on a commit. Options include: `include`: (default) All the status checks defined in the YAML file will be processed and sent as normal. `exclude`: Status checks that haven't newly uploaded any flag coverage will not be sent. `pass`: Status checks that haven't newly uploaded any flag coverage will be passed automatically. [More information](https://.codecov.com//commit-status#flag_coverage_not_uploaded_behavior)"
  },
  "coverage.status.patch.[any].flags": {
    "desc": "A list of user-defined Flags to use for the status check. The combined coverage from those flags will be reported."
  },
  "coverage.status.patch.[any].if_ci_failed": {
    "desc": "Options include: `error` (default) and `success`. `error` will set the Codecov status to success only if the CI is also successful. `success` will set the Codecov status to success even if CI fails"
  },
  "coverage.status.patch.[any].if_no_uploads": {
    "desc": "Deprecated"
  },
  "coverage.status.patch.[any].if_not_found": {
    "desc": "Options include: `success` (default) and `failure`. `success` will pass if there is no report for the HEAD commit. Use this on commits/PRs where you won't be uploading coverage but still want Codecov status checks to pass. `error` will fail if there is no report for the HEAD commit."
  },
  "coverage.status.patch.[any].include_changes": {
    "desc": "Deprecated"
  },
  "coverage.status.patch.[any].informational": {
    "desc": "Use Codecov in informational mode. Default is `false`. If `true` is specified the resulting status will pass no matter what the coverage is or what other settings are specified."
  },
  "coverage.status.patch.[any].measurement": {
    "desc": "Specify the type of coverage measurement. Options include: `line`, `statement`, `branch`, `method`, `complexity`"
  },
  "coverage.status.patch.[any].only_pulls": {
    "desc": "True / False binary to specify if you only want notifications to fire on pull requests (vs. individual commits on the branch). Default is `false`, which will notify on all new commits."
  },
  "coverage.status.patch.[any].paths": {
    "desc": "Similar to `flags`, a list of paths and/or regular expressions to use for the status check. The combined coverage from files that match will be reported."
  },
  "coverage.status.patch.[any].removed_code_behavior": {
    "desc": "Specify the behavior if coverage drops due to code removal. Options include: `removals_only`, `adjust_base`, `fully_covered_patch`, `off`, and `False`. See https://.codecov.com//commit-status#removed_code_behavior for more details."
  },
  "coverage.status.patch.[any].skip_if_assumes": {
    "desc": "Deprecated"
  },
  "coverage.status.patch.[any].target": {
    "desc": "Set the patch status check to a number (80), percent (80%), or `auto`. This specifies the minimum coverage number accepted by this patch status check. Setting to `auto` will compare coverage against the BASE commit."
  },
  "coverage.status.patch.[any].threshold": {
    "desc": "Allow coverage to drop by x% below the target and still pass the status check."
  },
  "coverage.status.project": {
    "desc": "Contains the configuration for a given project status check. Setting to False will disable the project status check."
  },
  "coverage.status.project.[any].base": {
    "desc": "The base commit type to which you would like to send notifications. Options include: 'parent', 'pr', and 'auto'. parent: compare the commit being notified on, to its direct parent. 'pr': compare the commit being notified on, to the base of a PR if the commit is in a PR. 'auto': automatically choose the appropriate comparison. If the commit being notified on is in a PR, pr will be used, otherwise parent will be used. This is the default."
  },
  "coverage.status.project.[any].branches": {
    "desc": "A list of the branches that, when used, will trigger this status."
  },
  "coverage.status.project.[any].carryforward_behavior": {
    "desc": "Determines how we handle status checks for which flags that were carried forward. This is useful if, for example, you're working on a project in a monorepo and don't want to see status checks related to other projects. Note that this only applies to status checks that specify flags. If there are no flags on a check, the status check will be processed as usual.  Options include: a.) 'include': (default) All the status checks defined in the YAML file will be processed and sent as normal b.) 'exclude': Status checks that carried forward coverage will not be included c.) 'pass': Status checks that have carried forward coverage will pass automatically."
  },
  "coverage.status.project.[any].disable_approx": {
    "desc": "Deprecated"
  },
  "coverage.status.project.[any].enabled": {
    "desc": "Deprecated"
  },
  "coverage.status.project.[any].flag_coverage_not_uploaded_behavior": {
    "desc": "Determines how to handle status checks for which no flag coverage (including carryforward flags) has been newly uploaded on a commit. Options include: `include`: (default) All the status checks defined in the YAML file will be processed and sent as normal. `exclude`: Status checks that haven't newly uploaded any flag coverage will not be sent. `pass`: Status checks that haven't newly uploaded any flag coverage will be passed automatically. [More information](https://.codecov.com//commit-status#flag_coverage_not_uploaded_behavior)"
  },
  "coverage.status.project.[any].flags": {
    "desc": "A list of user-defined Flags to use for the status check. The combined coverage from those flags will be reported."
  },
  "coverage.status.project.[any].if_ci_failed": {
    "desc": "Options include: `error` (default) and `success`. `error` will set the Codecov status to success only if the CI is also successful. `success` will set the Codecov status to success even if CI fails"
  },
  "coverage.status.project.[any].if_no_uploads": {
    "desc": "Deprecated"
  },
  "coverage.status.project.[any].if_not_found": {
    "desc": "Options include: `success` (default) and `failure`. `success` will pass if there is no report for the HEAD commit. Use this on commits/PRs where you won't be uploading coverage but still want Codecov status checks to pass. `error` will fail if there is no report for the HEAD commit."
  },
  "coverage.status.project.[any].include_changes": {
    "desc": "Deprecated"
  },
  "coverage.status.project.[any].informational": {
    "desc": "Use Codecov in informational mode. Default is `false`. If `true` is specified the resulting status will pass no matter what the coverage is or what other settings are specified."
  },
  "coverage.status.project.[any].measurement": {
    "desc": "Specify the type of coverage measurement. Options include: `line`, `statement`, `branch`, `method`, `complexity`"
  },
  "coverage.status.project.[any].only_pulls": {
    "desc": "True / False binary to specify if you only want notifications to fire on pull requests (vs. individual commits on the branch). Default is `false`, which will notify on all new commits."
  },
  "coverage.status.project.[any].paths": {
    "desc": "Similar to `flags`, a list of paths and/or regular expressions to use for the status check. The combined coverage from files that match will be reported."
  },
  "coverage.status.project.[any].removed_code_behavior": {
    "desc": "Specify the behavior if coverage drops due to code removal. Options include: `removals_only`, `adjust_base`, `fully_covered_patch`, `off`, and `False`. [More details](https://.codecov.com//commit-status#removed_code_behavior)"
  },
  "coverage.status.project.[any].skip_if_assumes": {
    "desc": "Deprecated"
  },
  "coverage.status.project.[any].target": {
    "desc": "Set the project status check to a number (80), percent (80%), or `auto`. This specifies the minimum coverage number accepted by this project status check. Setting to `auto` will compare coverage against the BASE commit."
  },
  "coverage.status.project.[any].threshold": {
    "desc": "Allow coverage to drop by x% below the target and still pass the status check."
  },
  "fixes": {
    "desc": "A list of path fixes that Codecov applies to uploaded coverage reports. Before using path fixing, [reading the documentation](https://docs.codecov.com/docs/fixing-paths) is greatly encouraged."
  },
  "flag_management": {
    "desc": "Allows you to control the behavior of flags during the code coverage analysis process."
  },
  "flag_management.default_rules": {
    "desc": "Rules are a set of defined conditions and actions that control the behavior of flags during the code coverage analysis process."
  },
  "flag_management.default_rules.after_n_builds": {
    "desc": "Refers to the ability to apply specific flag management rules after a certain number of builds or iterations. Gradually enforce stricter or different flag management behavior as your project progresses over time."
  },
  "flag_management.default_rules.carryforward": {
    "desc": "Carryforward Flags are designed for projects that do not upload total coverage for every commit. Users can define the following states for flags: True,  False,  yes,  no,  on,  off."
  },
  "flag_management.default_rules.carryforward_mode": {
    "desc": "Reference of past coverage for tests that are not run on current commit."
  },
  "flag_management.default_rules.ignore": {
    "desc": "To ignore or exclude specific files, directories, or patterns from flag management actions, you can define a flag management rule with conditions that exclude those specific elements."
  },
  "flag_management.default_rules.paths": {
    "desc": "Define rules that specify conditions and actions for flag management. These rules can be based on various criteria such as coverage thresholds, branch names, commit messages, or other factors relevant to your project."
  },
  "flag_management.default_rules.statuses": {
    "desc": "Flag management rule statuses refer to the different states or conditions associated with flag management rules."
  },
  "flag_management.individual_flags": {
    "desc": "Individual flags refer to specific configuration options or settings that can be used to customize the behavior of the code coverage reporting and analysis process."
  },
  "flags": {
    "desc": "A list of flags Codecov will apply in order to segment code coverage. Rules for flag names: min length: 1, max length: 45, pattern: ^[\\w\\.\\-]+$. Before using flags, [reading the documentation](https://docs.codecov.com/docs/flags) is greatly encouraged."
  },
  "flags.[any].after_n_builds": {
    "desc": "Value rules after N builds refer to coverage requirements or thresholds that are applied after a certain number of builds or iterations."
  },
  "flags.[any].assume": {
    "desc": "Deprecated"
  },
  "flags.[any].assume.branches": {
    "desc": "Deprecated"
  },
  "flags.[any].carryforward": {
    "desc": "Specify whether a flag should be Carryforward. See https://docs.codecov.com/docs/carryforward-flags for more details on Carryforward Flags."
  },
  "flags.[any].carryforward_mode": {
    "desc": "Specified whether a flag should carry its coverage forward to future commits. Carryforward flags is an advanced feature, and [reading the documentation]( https://docs.codecov.com/docs/flags#carryforward-flags) is recommended."
  },
  "flags.[any].ignore": {
    "desc": "Ignore coverage for specific lines of code. You can provide a comma-separated list of line ranges or individual line numbers to be ignored."
  },
  "flags.[any].joined": {
    "desc": "Specify whether or not the uploads associated with the flag should be joined with the master report or ignored during comparison."
  },
  "flags.[any].paths": {
    "desc": "Are used to define the paths to your project's source files or directories for which you want to generate code coverage reports."
  },
  "flags.[any].required": {
    "desc": "Deprecated"
  },
  "github_checks": {
    "desc": "Display code coverage information and analysis results directly within the GitHub interface. "
  },
  "github_checks.annotations": {
    "desc": "Checks enable users to see inline code annotations for contributed code on a PR that was not covered by tests, making it much easier for developers to see uncovered code contributions without leaving the GitHub PR."
  },
  "ignore": {
    "desc": "File paths for Codecov to ignore when processing coverage reports. [More information](https://docs.codecov.com/docs/ignoring-paths)"
  },
  "parsers": {
    "desc": "Configuration settings for Codecov various language-specific test coverage parsers. [More information:](https://docs.codecov.com/docs/codecovyml-reference#parsers)"
  },
  "parsers.gcov": {
    "desc": "Configuration options for the gcov coverage parser. [More information](https://.codecov.com/docs/codecovyml-reference#parsersgcov)"
  },
  "parsers.gcov.branch_detection": {
    "desc": "Controls how Codecov parses branch coverage in gcov reports. The coverage must exist in the uploaded report for us to parse it. [More information](https://.codecov.com//codecovyml-reference#parsersgcov)"
  },
  "parsers.gcov.branch_detection.conditional": {
    "desc": "Count conditional coverage lines toward the coverage total when using gcov. Options include: 'True', 'False', 'yes', 'no', 'on', 'off'."
  },
  "parsers.gcov.branch_detection.loop": {
    "desc": "Count loop coverage lines toward the coverage total when using gcov. Options include: 'True', 'False', 'yes', 'no', 'on', 'off'."
  },
  "parsers.gcov.branch_detection.macro": {
    "desc": "Count macro coverage lines toward the coverage total when using gcov. Options include: 'True', 'False', 'yes', 'no', 'on', 'off'."
  },
  "parsers.gcov.branch_detection.method": {
    "desc": "Count method coverage lines toward the coverage total when using gcov. Options include: 'True', 'False', 'yes', 'no', 'on', 'off'."
  },
  "parsers.go": {
    "desc": "Configuration options for Codecov's Golang coverage parser."
  },
  "parsers.go.partials_as_hits": {
    "desc": "Count partial coverage as hits for the Golang language. Useful to enable if Codecov is reporting lower coverage than your local reporting tool. Options include: 'True', 'False', 'yes', 'no', 'on', 'off'."
  },
  "parsers.jacoco": {
    "desc": "Configuration options for the gcov coverage parser. [More information](https://docs.codecov.com/docs/codecovyml-reference#parsersjacoco)"
  },
  "parsers.jacoco.partials_as_hits": {
    "desc": "Count partial coverage as hits for Jacoco coverage reports. Useful to enable if Codecov is reporting lower coverage than your local reporting tool. Options include: 'True', 'False', 'yes', 'no', 'on', 'off'."
  },
  "parsers.javascript": {
    "desc": "Configuration options for Codecov's JavaScript coverage parser."
  },
  "parsers.javascript.enable_partials": {
    "desc": "Count partial coverage as hits for the JavaScript language. Useful to enable if Codecov is reporting lower coverage than your local reporting tool. Options include: 'True', 'False', 'yes', 'no', 'on', 'off'."
  },
  "profiling": {
    "desc": "Impact Analysis requires a profiling token used to identify your repository and authenticate API requests. You can find your token in your repo settings page."
  },
  "profiling.critical_files_paths": {
    "desc": "You can supply any of the following as an element of critical_files_paths: 1. The fully qualified path to the file relative to the root of the repository, 2. A path containing globs. 3. A regular expression."
  },
  "profiling.fixes": {
    "desc": "Add path fixes to your codecov.yml configuration to see critical changes."
  },
  "profiling.grouping_attributes": {
    "desc": "Grouping attributes allow you to categorize your code coverage data based on specific criteria. These attributes can be applied to files, directories, or other relevant components of your codebase. Grouping attributes provide a way to aggregate and filter coverage information, enabling you to gain insights into different aspects of your codebase's test coverage."
  },
  "AI_PR_review": {
    "desc": "Experimental. Github Only. Codecov's bot will use OpenAI's GPT4 to make review comments on your Pull Requests. Data will be sent to OpenAI."
  },
  "AI_PR_review.enabled": {
    "desc": "Enable AI PR review."
  },
  "AI_PR_review.method": {
    "desc": "auto: all PRs will be reviews. label: only PRs labeled with `label_name` will be reviewed."
  },
  "AI_PR_review.label_name": {
    "desc": "Name of the label on github that will trigger a review. Ignored if `method` is not `label`."
  }
}
